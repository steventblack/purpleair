package purpleair

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"
)

// Global variables for retaining the API access keys.
// These are set via the SetAPIKey.
var (
	apiReadKey  string
	apiWriteKey string
)

type KeyType string   // maps the response from PurpleAir when checking the validity and permissions
type SensorIndex int  // uniquely identifies a sensor within the PurpleAir service
type SensorID string  // unique identifier of a sensor found on its label
type GroupID int      // unique identifier of a collection of sensors within the PurpleAir service
type MemberID int     // unique identifier of a sensor within a specific group defined in the PurpleAir service
type Location int     // enables typechecking on defined location values
type Privacy int      // setting for a sensor indicating public or private
type ChannelState int // States for the sensor data channel availability
type ChannelFlag int  // Flags for the sensor data channels

type Group struct {
	ID         GroupID `json:"id"`
	Name       string  `json:"name"`
	CreatedUTC int     `json:"created"`
}

type Member struct {
	ID         MemberID    `json:"id"`
	Index      SensorIndex `json:"sensor_index"`
	CreatedUTC int         `json:"created"`
}

// Private sensors must specify the owner's email and location in order to be accessed.
// Repeated failures to provide correct values for a private sensor may result in access key suspension.
type PrivateInfo struct {
	Email string
	Loc   Location
}

// GroupMember provides an abstract interface for referring to a sensor either by the SensorIndex,
// which is the reference generated by the PurpleAir service, or the SensorID, which is the
// reference available on the sensor device. Several calls provide flexibility on accepting
// either a SensorIndex or SensorID, so providing an abstraction helps reduce redundancy.
type GroupMember interface {
	AddMember(g GroupID, pi ...PrivateInfo) (MemberID, error)
}

// SensorFields specify which fields are to be returned for single-sensor calls (MemberData, SensorData).
// If omitted, then all available fields will be returned.
type SensorFields struct {
	Fields string `json:"fields,omitempty"` // comma-delimited list of sensor data fields to return (return all if omitted)
}

// Collection of averaged statistics for the sensor channel
type SensorStats struct {
	PM_2_5        float64 `json:"pm2.5"`
	PM_2_5_10Min  float64 `json:"pm2.5_10minute"`
	PM_2_5_30Min  float64 `json:"pm2.5_30minute"`
	PM_2_5_60Min  float64 `json:"pm2.5_60minute"`
	PM_2_5_6Hour  float64 `json:"pm2.5_6hour"`
	PM_2_5_24Hour float64 `json:"pm2.5_24hour"`
	PM_2_5_1Week  float64 `json:"pm2.5_1week"`
	Timestamp     int     `json:"time_stamp"`
}

// SensorInfo is the data response to a sensor query.
// Not all fields may be available depending on the query fields specified or hardware capabilities.
type SensorInfo struct {
	Index           SensorIndex  `json:"sensor_index,omitempty"`
	Icon            int          `json"icon,omitempty"`
	Name            string       `json:"name,omitempty"`
	Private         Privacy      `json:"private,omitempty"`
	Loc             Location     `json:"location_type,omitempty"`
	Lat             float64      `json:"latitude,omitempty"`
	Lng             float64      `json:"longitude,omitempty"`
	Alt             int          `json:"altitude,omitempty"`
	Pos             int          `json:"position_rating,omitempty"`
	Model           string       `json:"model,omitempty"`
	Hardware        string       `json:"hardware,omitempty"`
	FirmVersion     string       `json:"firmware_version,omitempty"`
	FirmUpgrade     string       `json:"firmware_upgrade,omitempty"`
	RSSI            int          `json:"rssi,omitempty"`
	Uptime          int          `json:"uptime,omitempty"`
	Latency         int          `json:"pa_latency,omitempty"`
	Memory          int          `json:"memory,omitempty"`
	LED             int          `json:"led_brightness,omitempty"`
	ChnlState       ChannelState `json:"channel_state,omitempty"`
	ChnlFlags       ChannelFlag  `json:"channel_flags,omitempty"`
	ChnlManual      ChannelFlag  `json:"channel_flags_manual,omitempty"`
	ChnlAuto        ChannelFlag  `json:"channel_flags_auto,omitempty"`
	Cfdnc           int          `json:"confidence,omitempty"`
	CfdncManual     int          `json:"confidence_manual,omitempty"`
	CfdncAuto       int          `json:"confidence_auto,omitempty"`
	Mod             int          `json:"last_modifed,omitempty"`
	Created         int          `json:"date_created,omitempty"`
	PM_1_0          float64      `json:"pm1.0,omitempty"`
	PM_1_0_A        float64      `json:"pm1.0_a,omitempty"`
	PM_1_0_B        float64      `json:"pm1.0_b,omitempty"`
	PM_1_0_Atm      float64      `json:"pm1.0_atm,omitempty"`
	PM_1_0_Atm_A    float64      `json:"pm1.0_atm_a,omitempty"`
	PM_1_0_Atm_B    float64      `json:"pm1.0_atm_b,omitempty"`
	PM_1_0_Cf_1     float64      `json:"pm1.0_cf_1,omitempty"`
	PM_1_0_Cf_1_A   float64      `json:"pm1.0_cf_1_a,omitempty"`
	PM_1_0_Cf_1_B   float64      `json:"pm1.0_cf_1_b,omitempty"`
	PM_2_5_Alt      float64      `json:"pm2.5_alt,omitempty"`
	PM_2_5_Alt_A    float64      `json:"pm2.5_alt_a,omitempty"`
	PM_2_5_Alt_B    float64      `json:"pm2.5_alt_b,omitempty"`
	PM_2_5          float64      `json:"pm2.5,omitempty"`
	PM_2_5_A        float64      `json:"pm2.5_a,omitempty"`
	PM_2_5_B        float64      `json:"pm2.5_b,omitempty"`
	PM_2_5_Atm      float64      `json:"pm2.5_atm,omitempty"`
	PM_2_5_Atm_A    float64      `json:"pm2.5_atm_a,omitempty"`
	PM_2_5_Atm_B    float64      `json:"pm2.5_atm_b,omitempty"`
	PM_2_5_Cf_1     float64      `json:"pm2.5_cf_1,omitempty"`
	PM_2_5_Cf_1_A   float64      `json:"pm2.5_cf_1_a,omitempty"`
	PM_2_5_Cf_1_B   float64      `json:"pm2.5_cf_1_b,omitempty"`
	PM_2_5_10Min    float64      `json:"pm2.5_10minute,omitempty"`
	PM_2_5_10Min_A  float64      `json:"pm2.5_10minute_a,omitempty"`
	PM_2_5_10Min_B  float64      `json:"pm2.5_10minute_b,omitempty"`
	PM_2_5_30Min    float64      `json:"pm2.5_30minute,omitempty"`
	PM_2_5_30Min_A  float64      `json:"pm2.5_30minute_a,omitempty"`
	PM_2_5_30Min_B  float64      `json:"pm2.5_30minute_b,omitempty"`
	PM_2_5_60Min    float64      `json:"pm2.5_60minute,omitempty"`
	PM_2_5_60Min_A  float64      `json:"pm2.5_60minute_a,omitempty"`
	PM_2_5_60Min_B  float64      `json:"pm2.5_60minute_b,omitempty"`
	PM_2_5_6Hour    float64      `json:"pm2.5_6hour,omitempty"`
	PM_2_5_6Hour_A  float64      `json:"pm2.5_6hour_a,omitempty"`
	PM_2_5_6Hour_B  float64      `json:"pm2.5_6hour_b,omitempty"`
	PM_2_5_24Hour   float64      `json:"pm2.5_24hour,omitempty"`
	PM_2_5_24Hour_A float64      `json:"pm2.5_24hour_a,omitempty"`
	PM_2_5_24Hour_B float64      `json:"pm2.5_24hour_b,omitempty"`
	PM_2_5_1Week    float64      `json:"pm2.5_1week,omitempty"`
	PM_2_5_1Week_A  float64      `json:"pm2.5_1week_a,omitempty"`
	PM_2_5_1Week_B  float64      `json:"pm2.5_1week_b,omitempty"`
	PM_10_0         float64      `json:"pm10.0,omitempty"`
	PM_10_0_A       float64      `json:"pm10.0_a,omitempty"`
	PM_10_0_B       float64      `json:"pm10.0_b,omitempty"`
	PM_10_0_Atm     float64      `json:"pm10.0_atm,omitempty"`
	PM_10_0_Atm_A   float64      `json:"pm10.0_atm_a,omitempty"`
	PM_10_0_Atm_B   float64      `json:"pm10.0_atm_b,omitempty"`
	PM_10_0_Cf_1    float64      `json:"pm10.0_cf_1,omitempty"`
	PM_10_0_Cf_1_A  float64      `json:"pm10.0_cf_1_a,omitempty"`
	PM_10_0_Cf_1_B  float64      `json:"pm10.0_cf_1_b,omitempty"`
	PC_0_3um        int          `json:"0.3_um_count,omitempty"`
	PC_0_3um_A      int          `json:"0.3_um_count_a,omitempty"`
	PC_0_3um_B      int          `json:"0.3_um_count_b,omitempty"`
	PC_0_5um        int          `json:"0.5_um_count,omitempty"`
	PC_0_5um_A      int          `json:"0.5_um_count_a,omitempty"`
	PC_0_5um_B      int          `json:"0.5_um_count_b,omitempty"`
	PC_1_0um        int          `json:"1.0_um_count,omitempty"`
	PC_1_0um_A      int          `json:"1.0_um_count_a,omitempty"`
	PC_1_0um_B      int          `json:"1.0_um_count_b,omitempty"`
	PC_2_5um        int          `json:"2.5_um_count,omitempty"`
	PC_2_5um_A      int          `json:"2.5_um_count_a,omitempty"`
	PC_2_5um_B      int          `json:"2.5_um_count_b,omitempty"`
	PC_5_0um        int          `json:"5.0_um_count,omitempty"`
	PC_5_0um_A      int          `json:"5.0_um_count_a,omitempty"`
	PC_5_0um_B      int          `json:"5.0_um_count_b,omitempty"`
	PC_10_0um       int          `json:"10.0_um_count,omitempty"`
	PC_10_0um_A     int          `json:"10.0_um_count_a,omitempty"`
	PC_10_0um_B     int          `json:"10.0_um_count_b,omitempty"`
	Stats           SensorStats  `json:"stats,omitempty"`
	Stats_A         SensorStats  `json:"stats_a,omitempty"`
	Stats_B         SensorStats  `json:"stats_b,omitempty"`
	Humidity        int          `json:"humidity,omitempty"`
	Humidity_A      int          `json:"humidity_a,omitempty"`
	Humidity_B      int          `json:"humidity_b,omitempty"`
	Temp            int          `json:"temperature,omitempty"`
	Temp_A          int          `json:"temperature_a,omitempty"`
	Temp_B          int          `json:"temperature_b,omitempty"`
	Pressure        float64      `json:"pressure,omitempty"`
	Pressure_A      float64      `json:"pressure_a,omitempty"`
	Pressure_B      float64      `json:"pressure_b,omitempty"`
	VOC             float64      `json:"voc,omitempty"`
	VOC_A           float64      `json:"voc_a,omitempty"`
	VOC_B           float64      `json:"voc_b,omitempty"`
	Ozone           float64      `json:"ozone1,omitempty"`
	AnalogIn        float64      `json:"analog_input,omitempty"`
	PrimaryID_A     int          `json:"primary_id_a,omitempty"`
	PrimaryKey_A    string       `json:"primary_key_a,omitempty"`
	SecondaryID_A   int          `json:"secondary_id_a,omitempty"`
	SecondaryKey_A  string       `json:"secondary_key_a,omitempty"`
	PrimaryID_B     int          `json:"primary_id_b,omitempty"`
	PrimaryKey_B    string       `json:"primary_key_b,omitempty"`
	SecondaryID_B   int          `json:"secondary_id_b,omitempty"`
	SecondaryKey_B  string       `json:"secondary_key_b,omitempty"`
}

// KeyTypes as returned from PurpleAir.
const (
	APIKEYUNKNOWN       KeyType = "UNKNOWN"
	APIKEYREAD          KeyType = "READ"
	APIKEYWRITE         KeyType = "WRITE"
	APIKEYREADDISABLED  KeyType = "READ_DISABLED"
	APIKEYWRITEDISABLED KeyType = "WRITE_DISABLED"
)

// Defined location values
const (
	OUTSIDE Location = 0
	INSIDE  Location = 1
)

// Defined privacy values
const (
	PUBLIC  Privacy = 0
	PRIVATE Privacy = 1
)

// Defined channel states
const (
	PM_NONE ChannelState = 0 // no PM sensors detected
	PM_A    ChannelState = 1 // PM sensor only on channel A
	PM_B    ChannelState = 2 // PM sensor only on channel B
	PM_ALL  ChannelState = 3 // PM sensors on both channel A & B
)

// Defined channel flags
const (
	NORMAL         ChannelFlag = 0 // no sensors marked as downgraded
	DOWNGRADED_A   ChannelFlag = 1 // channel A sensors downgraded
	DOWNGRADED_B   ChannelFlag = 2 // channel B sensors downgraded
	DOWNGRADED_ALL ChannelFlag = 3 // both channel A & B sensors downgraded
)

// PurpleAir API paths
const (
	URLKEYS    string = "https://api.purpleair.com/v1/keys"
	URLGROUPS  string = "https://api.purpleair.com/v1/groups"
	URLMEMBERS string = "https://api.purpleair.com/v1/groups/%d/members"
	URLSENSORS string = "https://api.purpleair.com/v1/sensors"
)

// APIKEYHEADER is the HTTP Request header used to pass in the access key value.
const APIKEYHEADER string = "X-API-Key"

// SetAPIKey checks the validity and permissions of the provided access key string.
// If the key is valid, it will be retained by the module for further calls.
// Only one key for each permission (read or write) will be retained, and additional
// calls with other valid keys will result in replacement.
// The KeyType will be returned on success, or an error on failure.
func SetAPIKey(k string) (KeyType, error) {
	keyType, err := CheckAPIKey(k)
	if err != nil {
		return APIKEYUNKNOWN, err
	}

	if keyType == APIKEYREAD {
		apiReadKey = k
	} else if keyType == APIKEYWRITE {
		apiWriteKey = k
	}

	return keyType, nil
}

// CheckAPIKey checks the validity and permissions of the provided access key string.
// It does *not* retain the key for further calls. Use SetAPIKey if retention is desired.
// The KeyType will be returned on success, or an error on failure.
func CheckAPIKey(k string) (KeyType, error) {
	type checkKeyType struct {
		V string  `json:"api_version"`
		T int     `json:"time_stamp"`
		K KeyType `json:"api_key_type"`
	}
	var keyTypeResp checkKeyType

	keyType := APIKEYUNKNOWN

	req, err := http.NewRequest(http.MethodGet, URLKEYS, nil)
	if err != nil {
		return keyType, err
	}
	req.Header.Add(APIKEYHEADER, k)

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return keyType, err
	}
	defer resp.Body.Close()

	// if invalid key, an error is returned
	if resp.StatusCode != http.StatusCreated {
		return keyType, extractError(resp)
	}

	decoder := json.NewDecoder(resp.Body)
	err = decoder.Decode(&keyTypeResp)
	if err != nil {
		return keyType, err
	}

	return keyTypeResp.K, nil
}

// CreateGroup creates a persistent reference of a defined set of sensors on the PurpleAir service.
// Sensors can be added/removed using the membership APIs.
// This call requires a key with write permissions to be set prior to calling.
// A GroupID will be returned on success, or an error on failure.
func CreateGroup(g string) (GroupID, error) {
	reqBody := struct {
		GroupName string `json:"name"`
	}{GroupName: g}

	reqJSON, err := json.Marshal(reqBody)
	if err != nil {
		return 0, err
	}

	req, err := setupCall(http.MethodPost, URLGROUPS, reqJSON)
	if err != nil {
		return 0, err
	}

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return 0, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusCreated {
		return 0, extractError(resp)
	}

	groupResp := struct {
		V string  `json:"api_version"`
		T int     `json:"time_stamp"`
		G GroupID `json:"group_id"`
	}{}

	decoder := json.NewDecoder(resp.Body)
	err = decoder.Decode(&groupResp)
	if err != nil {
		return 0, err
	}

	return groupResp.G, nil
}

// DeleteGroup deletes the persistent reference of a sensor group on the PurpleAir service.
// All sensor members must be removed prior to group deletion.
// This call requires a key with write permissions to be set prior to calling.
// An error will be returned on failure, or else nil
func DeleteGroup(g GroupID) error {
	url := fmt.Sprintf("%s/%d", URLGROUPS, g)
	req, err := setupCall(http.MethodDelete, url, nil)
	if err != nil {
		return err
	}

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	// if unexpected response, extract & return the error
	if resp.StatusCode != http.StatusNoContent {
		return extractError(resp)
	}

	return nil
}

// ListGroups provides all groups defined in the PurpleAir service associated with the access key.
// This call requires a key with read permissions to be set prior to calling.
// The list of groups will be returned on success, or else an error.
func ListGroups() ([]Group, error) {
	req, err := setupCall(http.MethodGet, URLGROUPS, nil)
	if err != nil {
		return nil, err
	}

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, extractError(resp)
	}

	groupResp := struct {
		V string  `json:"api_version"`
		T int     `json:"time_stamp"`
		D int     `json:"data_time_stamp"`
		G []Group `json:"groups"`
	}{}

	decoder := json.NewDecoder(resp.Body)
	err = decoder.Decode(&groupResp)
	if err != nil {
		return nil, err
	}

	return groupResp.G, nil
}

// GroupDetails provides the list of member sensors defined for the specified group.
// This call requires a key with read permissions to be set prior to calling.
// The list of members will be returned on success, or else an error.
func GroupDetails(g GroupID) ([]Member, error) {
	url := fmt.Sprintf("%s/%d", URLGROUPS, g)
	req, err := setupCall(http.MethodGet, url, nil)
	if err != nil {
		return nil, err
	}

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, extractError(resp)
	}

	memberResp := struct {
		V string   `json:"api_version"`
		T int      `json:"time_stamp"`
		D int      `json:"data_time_stamp"`
		G GroupID  `json:"group_id"`
		M []Member `json:"members"`
	}{}

	decoder := json.NewDecoder(resp.Body)
	err = decoder.Decode(&memberResp)
	if err != nil {
		return nil, err
	}

	return memberResp.M, nil
}

// AddMember provides the SensorIndex interface solution to adding a sensor to a group.
// The function takes an optional PrivateInfo struct, which is necessary only if the
// sensor referenced is a private sensor.
// This call requires a key with write permissions to be set prior to calling.
// The MemberID will be returned on success, or else an error.
func (s SensorIndex) AddMember(g GroupID, pi ...PrivateInfo) (MemberID, error) {
	reqBody := struct {
		S SensorIndex `json:"sensor_index"`
		E string      `json:"owner_email,omitempty"`
		L Location    `json:"location_type,omitempty"`
	}{S: s}

	// If private info supplied, update the struct to include those components
	if pi != nil {
		reqBody.E = pi[0].Email
		reqBody.L = pi[0].Loc
	}

	reqJSON, err := json.Marshal(reqBody)
	if err != nil {
		return 0, err
	}

	return addMember(g, reqJSON)
}

// AddMember provides the SensorID interface solution to adding a sensor to a group.
// The function takes an optional PrivateInfo struct, which is necessary only if the
// sensor referenced is a private sensor.
// This call requires a key with write permissions to be set prior to calling.
// The MemberID will be returned on success, or else an error.
func (s SensorID) AddMember(g GroupID, pi ...PrivateInfo) (MemberID, error) {
	reqBody := struct {
		S SensorID `json:"sensor_id"`
		E string   `json:"owner_email,omitempty"`
		L Location `json:"location_type,omitempty"`
	}{S: s}

	// If private info supplied, update the struct to include those components
	if pi != nil {
		reqBody.E = pi[0].Email
		reqBody.L = pi[0].Loc
	}

	reqJSON, err := json.Marshal(reqBody)
	if err != nil {
		return 0, err
	}

	return addMember(g, reqJSON)
}

// addMember is the private function for handling the common code for member addition.
// Both the SensorID and SensorIndex versions of AddMember rely on this.
func addMember(g GroupID, reqJSON []byte) (MemberID, error) {
	url := fmt.Sprintf(URLMEMBERS, g)
	req, err := setupCall(http.MethodPost, url, reqJSON)
	if err != nil {
		return 0, err
	}

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return 0, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusCreated {
		return 0, extractError(resp)
	}

	memberResp := struct {
		V string   `json:"api_version"`
		T int      `json:"time_stamp"`
		D int      `json:"data_time_stamp"`
		G GroupID  `json:"group_id"`
		M MemberID `json:"member_id"`
	}{}

	decoder := json.NewDecoder(resp.Body)
	err = decoder.Decode(&memberResp)
	if err != nil {
		return 0, err
	}

	return memberResp.M, nil
}

// RemoveMember removes the member specified from the group specified.
// This call requires a key with write permissions to be set prior to calling.
// On success, nil will be returned or else an error.
func RemoveMember(m MemberID, g GroupID) error {
	url := fmt.Sprintf(URLMEMBERS+"/%d", g, m)
	req, err := setupCall(http.MethodDelete, url, nil)
	if err != nil {
		return err
	}

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusNoContent {
		return extractError(resp)
	}

	return nil
}

// MemberData returns the SensorInfo for a member of a group.
// The optional SensorFields parameter can restrict the information returned to the named fields.
// Omitting the SensorFields parameter will return all available information fields.
// This call requires a key with read permissions to be set prior to calling.
// On success, the SensorInfo will be returned, or else an error.
func MemberData(g GroupID, m MemberID, f ...SensorFields) (*SensorInfo, error) {
	url := fmt.Sprintf(URLMEMBERS+"/%d", g, m)

	return sensorDataCommon(url, f)
}

// SensorData returns the SensorInfo for the named SensorIndex.
// The optional SensorFields parameter can restrict the information returned to the named fields.
// Omitting the SensorFields parameter will return all available information fields.
// This call requires a key with read permissions to be set prior to calling.
// On success, the SensorInfo will be returned, or else an error.
func SensorData(s SensorIndex, f ...SensorFields) (*SensorInfo, error) {
	url := fmt.Sprintf(URLSENSORS+"/%d", s)

	return sensorDataCommon(url, f)
}

func sensorDataCommon(url string, f []SensorFields) (*SensorInfo, error) {
	req, err := setupCall(http.MethodGet, url, nil)
	if err != nil {
		return nil, err
	}

	switch len(f) {
	case 0:
		// if nothing specified, then skip
	case 1:
		q := req.URL.Query()
		q.Add("fields", f[0].Fields)
		req.URL.RawQuery = q.Encode()
	default:
		return nil, errors.New("Too many SensorFields specified (max 1)")
	}

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, extractError(resp)
	}

	sensorResp := struct {
		V string     `json:"api_version"`
		T int        `json:"time_stamp"`
		D int        `json:"data_time_stamp"`
		S SensorInfo `json:"sensor"`
	}{}

	decoder := json.NewDecoder(resp.Body)
	err = decoder.Decode(&sensorResp)
	if err != nil {
		return nil, err
	}

	return &sensorResp.S, nil
}

// MembersData returns the information requested for the set (or subset)
// of sensors within the specified Group. The SensorParams must specify
// the elements requested in the "fields" parameter.
// The return value is a map of key/value pairs for each field element
// specified indexed by the sensor_index.
func MembersData(g GroupID, sp SensorParams) (SensorDataSet, error) {
	u, err := url.Parse(fmt.Sprintf(URLMEMBERS, g))
	if err != nil {
		return nil, err
	}

	err = addSensorParams(u, sp)
	if err != nil {
		return nil, err
	}

	d, err := sensorsInfo(u, sp)

	return d, err
}

// SensorsData returns the information requested for the set
// of sensors specified as a comma-delimited list of values for the
// sensors_index parameter. The SensorParams must specify
// the elements requested in the "fields" parameter.
// The return value is a map of key/value pairs for each field element
// specified indexed by the sensor_index.
func SensorsData(sp SensorParams) (SensorDataSet, error) {
	u, err := url.Parse(URLSENSORS)
	if err != nil {
		return nil, err
	}

	err = addSensorParams(u, sp)
	if err != nil {
		return nil, err
	}

	d, err := sensorsInfo(u, sp)

	return d, err
}

// setupCall performs common tasks that are prerequisite before calling the API.
// It initializes a request object and adds the appropriate key (read or write) to the request.
// It returns a request ready for execution or an error.
func setupCall(method string, url string, reqBody []byte) (*http.Request, error) {
	req, err := http.NewRequest(method, url, bytes.NewBuffer(reqBody))
	if err != nil {
		return nil, err
	}

	switch method {
	case "GET":
		if len(apiReadKey) == 0 {
			return nil, errors.New("PurpleAir key not set [read]")
		}
		req.Header.Add(APIKEYHEADER, apiReadKey)
	case "POST", "DELETE":
		if len(apiWriteKey) == 0 {
			return nil, errors.New("PurpleAir key not set [write]")
		}
		req.Header.Add(APIKEYHEADER, apiWriteKey)
	}
	req.Header.Add("Content-Type", "application/json")

	return req, nil
}

// extractError handles an error response back from the API and returns an error
func extractError(r *http.Response) error {
	errorResp := struct {
		V string `json:"api_version"`
		T int    `json:"time_stamp"`
		E string `json:"error"`
		D string `json:"description"`
	}{}

	decoder := json.NewDecoder(r.Body)
	err := decoder.Decode(&errorResp)
	if err != nil {
		return err
	}

	// If there is an error response and description, use both. Otherwise just repor the error.
	errMsg := errorResp.E
	if errorResp.D != "" {
		errMsg = fmt.Sprintf("%s: %s", errorResp.E, errorResp.D)
	}

	return errors.New(errMsg)
}
